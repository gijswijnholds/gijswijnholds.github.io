
<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8" />
<title>Alignment constraints with guidelines</title>
<style>

.group {
  stroke: #fff;
  stroke-width: 1.5px;
  cursor: move;
  fill: none;
  opacity: 0.4;
}

.node {
  stroke: #000;
  stroke-width: 1.5px;
  cursor: move;
}

.link {
  stroke: #000;
  stroke-width: 3px;
  stroke-opacity: 1;
}

</style>
</head>
<body>
    <h1>Alignment constraints with guidelines</h1>
<script src="./static/d3.min.js"></script>
<script src="./static/cola.min.js"></script>
<script>
    var width = 1024,
        height = 800;

    var color = d3.scale.category20();

    var d3cola = cola.d3adaptor()
        .linkDistance(120)
        .avoidOverlaps(true)
        .size([width, height]);

    var svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height);

    var lineFunction = d3.svg.line()
        .x(function(d) { return d.x; })
        .y(function(d) { return d.y; })
        .interpolate("basis");

    d3.json("alignmentconstraints.json", function (error, graph) {
        return layoutAndRunGraph(graph);
    });

    function layoutAndRunGraph (graph) {
        graph.nodes.forEach(function (v) { v.x = 400, v.y = 50 });
        d3cola
            .nodes(graph.nodes)
            .links(graph.links)
            .constraints(graph.constraints)
            .groups(graph.groups)
            .start(10,10,10);

        var group = svg.selectAll(".group")
            .data(graph.groups)
            .enter().append("rect")
            .attr("rx", 8).attr("ry", 8)
            .attr("class", "group")
            .attr("id", function (d) { return d.name; });

        var link = svg.selectAll(".link")
            .data(graph.links)
          .enter().append("path")
            .attr("class", "link");

        var node = svg.selectAll(".node")
            .data(graph.nodes)
          .enter().append("rect")
            .attr("class", "node")
            .attr("width", function (d) { return d.width; })
            .attr("height", function (d) { return d.height; })
            .attr("rx", 5).attr("ry", 5)
            .attr("group", function (d) { return d.group; })
            .style("fill", "white")
            .call(d3cola.drag)
            .on("mouseover", showGroup)
            .on("mouseout", hideGroup)
            .on("dblclick", function (d) { return collapseGroup(d, graph); });

        d3cola.on("tick", function () {
            link.attr("d", function (d) { return makeLine(d); })
            .attr("fill", "none");

            group.attr("x", function (d) { return d.bounds.x; })
                .attr("y", function (d) { return d.bounds.y; })
                .attr("width", function (d) { return d.bounds.width(); })
                .attr("height", function (d) { return d.bounds.height(); });

            node.attr("x", function (d) { return d.x - d.width / 2; })
                    .attr("y", function (d) { return d.y - d.height / 2; });

        });
    };

    function logInNode(d, graph) {
      var group = graph.groups.filter(function (g) { return g.name == d.group; })[0];

      if(group.in) {
        console.log(graph.nodes[group.in].name);
      }
      else {
        console.log("no in node found!");
      }
    }

    function collapseGroup(d, graph) {
      var nodes = graph.nodes;
      var links = graph.links;
      var constraints = graph.constraints;
      var groups = graph.groups;

      var group = groups.filter(function (g) { return g.name == d.group})[0];
      var groupName = group.name;

      if (group.in && group.out) {
        // do all stuff
        var newGraph = graph;
        // steps: remove nodes and links in group
        newGraph.nodes = newGraph.nodes.filter(function (node) {
          return node.group != groupName;
        })
        var inLink = newGraph.links.filter(function (link) {
          return link.source.group != groupName && link.target.group == groupName;
        })[0];
        var outLink = newGraph.links.filter(function (link) {
          return link.source.group == groupName && link.target.group != groupName;
        })[0];
        newGraph.links = newGraph.links.filter(function (link) {
          return link.source.group != groupName && link.target.group != groupName;
        });
        // add groupnode
        var groupNode = {"type":"groupnode","name":groupName,"group":groupName,"width":80,"height":80};
        newGraph.nodes.push(groupNode);
        // remember in link and out link and use these to make new links to groupnode
        var newInLink = {"curve" : inLink.curve, "source" : inLink.source, "target": newGraph.nodes.length-1};
        var newOutLink = {"curve" : outLink.curve, "source" : newGraph.nodes.length-1, "target" : outLink.target};
        newGraph.links.push(newInLink);
        newGraph.links.push(newOutLink);
        // delete nodes from group
        newGraph.groups = newGraph.groups.filter(function (g) {
          return g.name != groupName;
        })
        // restart
        var newNodeNames = newGraph.nodes.map(function (d) { return d.name;});
        newGraph.constraints = newGraph.constraints.filter(function (c) {
          return isElementOf(c.left.name, newNodeNames) && isElementOf(c.right.name, newNodeNames);
        });
        console.log(newGraph.groups);

        // PROBLEEM HIER: in de supergroepen van de groep, de groupNode aan leaves toevoegen
        d3cola.stop();
        d3cola.on("tick",null);
        layoutAndRunGraph(newGraph);
      }
    }

    function isElementOf(obj, arr) {
      return arr.indexOf(obj) != 1;
    }

    function showGroup(d) {
        d3.select("#" + d.group)
        .style("fill", "blue");
    }

    function hideGroup(d) {
      d3.select("#" + d.group)
      .style("fill", "none");
    }

    function makeLine(d) {
      var lineData;
      var point3 = calculateCurve(d);

      if(point3) {
        lineData = [d.source, point3, d.target];
      }
      else {
        lineData = [d.source, d.target];
      }
      return lineFunction(lineData);
    }

    function calculateCurve(d) {
      if (d.curve == "left-down" || d.curve == "right-down") {
        return {"x" : d.target.x, "y" : d.source.y + 0.35 * (d.target.y - d.source.y) };
      }
      if (d.curve == "down-left" || d.curve == "down-right") {
        return {"x" : d.source.x, "y" : d.target.y - 0.35 * (d.target.y - d.source.y)};
      }
      if (d.curve == "left-up" || d.curve == "right-up") {
        return {"x" : d.target.x, "y" : d.source.y - 0.35 * (d.source.y - d.target.y) };
      }
      if (d.curve == "up-left" || d.curve == "up-right") {
        return {"x" : d.source.x, "y" : d.target.y + 0.35 * (d.source.y - d.target.y) };
      }
      return null;
    }

    function getAlignmentBounds(vs, c) {
        var os = c.offsets;
        if (c.axis === 'x') {
            var x = vs[os[0].node].x;
            c.bounds = new cola.vpsc.Rectangle(x, x,
                Math.min.apply(Math, os.map(function (o) { return vs[o.node].bounds.y - 20; })),
                Math.max.apply(Math, os.map(function (o) { return vs[o.node].bounds.Y + 20; })));
        } else {
            var y = vs[os[0].node].y;
            c.bounds = new cola.vpsc.Rectangle(
                Math.min.apply(Math, os.map(function (o) { return vs[o.node].bounds.x - 20; })),
                Math.max.apply(Math, os.map(function (o) { return vs[o.node].bounds.X + 20; })),
                y, y);
        }
        return c.bounds;
    }

</script>
</body>
</html>
